<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: UI/ftMain.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: UI/ftMain.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>ï»¿/**
 * @file Logic tree functions.
 * @copyright 2021 Battelle Energy Alliance
 */


'use strict';
// Makes the shadow brighter
mxConstants.SHADOWCOLOR = '#C0C0C0';

/**
 * Main program.
 * 
 * @param {HTMLElement} container The element to create the app within.
 * @param {HTMLElement} outline The app outline element.
 */
function main(container, outline) {
  var projName = '';
	var ftName = '';

  // Checks if browser is supported
  if (!mxClient.isBrowserSupported()) {
    // Displays an error message if the browser is
    // not supported.
    mxUtils.error('Browser is not supported!', 200, false);
  }
  else {
    // Workaround for Internet Explorer ignoring certain styles
    mxEvent.disableContextMenu(container);
    if (mxClient.IS_QUIRKS) {
      document.body.style.overflow = 'hidden';
      new mxDivResizer(container);
      new mxDivResizer(outline);
    }
    document.body.appendChild(container);

    // Creates a wrapper editor with a graph inside the given container.
    // The editor is used to create certain functionality for the
    // graph, such as the rubberband selection, but most parts
    // of the UI are custom in this example.
    var editor = new mxEditor();
    var graph = editor.graph;

    // Creates the graph inside the given container
    //graph = new mxGraph(container);
    // Sets the graph container and configures the editor
    editor.setGraphContainer(container);
    var config = mxUtils.load(
      //'config/keyhandler-commons.xml'  // disabled F12 key for developer tool in browser.
      'config/keyhandler-minimal.xml'  //for debugging F12 enabled  keycode(123) == F12.
      )
      .getDocumentElement();
    editor.configure(config);


    // Enables automatic sizing for vertices after editing and
    // panning by using the left mouse button.
    graph.setCellsMovable(false);
    graph.setAutoSizeCells(false);
    graph.cellsResizable = (false);
    graph.setHtmlLabels(true);
    graph.setPanning(true);
    graph.centerZoom = false;
    graph.panningHandler.useLeftButtonForPanning = true;
    graph.keepEdgesInBackground = true
    graph.setDropEnabled(true);


    // Displays a popupmenu when the user clicks
    // on a cell (using the left mouse button) but
    // do not select the cell when the popup menu
    // is displayed
    graph.panningHandler.popupMenuHandler = false;

    // Creates the outline (navigator, overview) for moving
    // around the graph in the top, right corner of the window.
    var outln = new mxOutline(graph, outline);

    // Disables tooltips on touch devices
    graph.setTooltips(!mxClient.IS_TOUCH);

    configureStyleSheets(graph);

    // Stops editing on enter or escape keypress
    var keyHandler = new mxKeyHandler(graph);

    // Enables automatic layout on the graph and installs
    // a tree layout for all groups who's children are
    // being changed, added or removed.
    var layout = new mxCompactTreeLayout(graph, false);
    layout.useBoundingBox = false;
    layout.edgeRouting = false;
    layout.levelDistance = 60;
    layout.nodeDistance = 16;

    // Allows the layout to move cells even though cells
    // aren't movable in the graph
    layout.isVertexMovable = function (cell) {
      return true;
    };

    var layoutMgr = new mxLayoutManager(graph);

    layoutMgr.getLayout = function (cell) {
      if (cell.getChildCount() > 0) {
        return layout;
      }
    };

    //-------------------------------------------------------------
    // Installs a popupmenu handler using local function (see below).
    graph.panningHandler.factoryMethod = function (menu, cell, evt) {
      return createPopupMenu(graph, menu, cell, evt);
    };

    //-------------------------------------------------------------
    // Fix for wrong preferred size
    var oldGetPreferredSizeForCell = graph.getPreferredSizeForCell;
    graph.getPreferredSizeForCell = function (cell) {
      var result = oldGetPreferredSizeForCell.apply(this, arguments);
      //TODO: testingo only.
      return result;

      if (result != null) {
        result.width = Math.max(120, result.width - 40);
      }

      return result;
    };

    //-------------------------------------------------------------
    // Sets the maximum text scale to 1
    graph.cellRenderer.getTextScale = function (state) {
      return Math.min(1, state.view.scale);
    };

    //-------------------------------------------------------------
    var GetFTItem = function (cell) {
      if (cell instanceof mxCell) {
        if (cell.children == null) {
          return null;
        }

        for (var i = 0; i &lt; cell.children.length; i++) {
          var cellVal = cell.children[i].value;
          if ((cellVal != null) &amp;&amp; (cellVal instanceof FTItem)) {
            return cellVal;
          }
        }
      }

      return null;
    }
    //-------------------------------------------------------------
    var editFunc = function EditLabel(lbl) {
      alert(lbl);
    }
    //-------------------------------------------------------------
    // Sets the new value for the given cell and trigger
    graph.labelChanged = function (cell, newValue, trigger) {
      cell.value = newValue;

      if ((cell.parent != null) &amp;&amp; (cell.parent.value instanceof FTItem)) {
        var nodePart = cell.id.split('~');
        nodePart = nodePart[nodePart.length - 1];
        switch (nodePart) {
          case 'Name':
            cell.parent.value.name = newValue;
            break;

          case 'Desc':
            cell.parent.value.desc = newValue;
            break;

          case 'Value':
            cell.parent.value.value = newValue;
            break;
        }
      }

      mxGraph.prototype.labelChanged.apply(this, arguments);
    }
    //-------------------------------------------------------------
         // Sets the new value for the given cell and trigger
    //TODO
    graph.gateChanged = function (cell, newValue, trigger) {
        cell.value = newValue;
        //var x = tree;

    }
    //-------------------------------------------------------------
    graph.isCellEditable = function (cell) {
      return ((cell.parent != null) &amp;&amp; (cell.parent.value instanceof FTItem));
    };
    //-------------------------------------------------------------
    graph.getLabel = function (cell) {
      var tmp = '';
      if (cell &amp;&amp; cell.isEdge() == true) return '';

      if (cell &amp;&amp; cell.value) {
        if (cell.value instanceof FTItem) {
						if (!cell.collapsed) {  
								if (cell.id.indexOf("~Desc") > 0)
										return cell.value.desc;
								return cell.value.name;
						}
						
          else {
            return cell.value.name;
          }
        }
        if (cell.value.gateType) { //LogicNode gate
          if (cell.id.indexOf("~Name") > 0)
            tmp = cell.value.name;
          else tmp = cell.value.desc + "  ";
        }
        else if (cell.value.diagramType) { //DiagramType
          tmp = cell.value.name;
        }
      }
      else tmp = mxGraph.prototype.getLabel.apply(this, arguments); // "supercall"

      return tmp;
    };


    //overwritten cellRenderer.redrawLabel to install drag/drop.  We can only do D&amp;D on DOME element.
    var oldRedrawLabel = graph.cellRenderer.redrawLabel;
    graph.cellRenderer.redrawLabel = function (state) {

      //When the shape is redrawing its label, mxGraph destroys the content, so we need to re-install drop handler each time. 
      var installDropHandler = function (watchEl) {

        // handler for item drag over response
        // NOTE: the dragover is attach to the label's parent div.  So it can only be drop onto the label, for now.
        watchEl.ondragover = function (evt) {
        //mxEvent.addListener(watchEl, 'dragover', function (evt) {
          var isDiagram = false;
						var isGate = false;
          if (evt.dataTransfer.types.indexOf('diagrams') >= 0 &amp;&amp; evt.dataTransfer.types.indexOf('dtcomponent') >= 0) {
            //TODO: if the diagram can only be drop to specific type of shape, the evt.target is the pdiv.  
            //When construct the shape, the mxCell.shate can be link to the div so we can get back to the object that containing the div.
            isDiagram = true;
          }
					if (evt.dataTransfer.types.indexOf('gate') >= 0) {
            //TODO: if the diagram can only be drop to specific type of shape, the evt.target is the pdiv.  
            //When construct the shape, the mxCell.shate can be link to the div so we can get back to the object that containing the div.
							isGate = true;
          }
						
          //drop allows
						if (isDiagram || isGate) {
								evt.preventDefault();  //tell drag it is okay to drop.
								evt.stopPropagation();
						}
						
						//TODO add error message here (only can drag component diagram)
        }.bind(watchEl);

        //handler for actual drop of drag over item.
        watchEl.ondrop = function (evt) {
        //mxEvent.addListener(watchEl, 'drop', function (evt) {
						if (evt.dataTransfer.types.indexOf('diagrams') >= 0) {
								var newDiagram = evt.dataTransfer.getData("diagrams");
								if (newDiagram !== '') {
										var target = evt.target;
										newDiagram = JSON.parse(newDiagram);

										//TODO: task to add diagram to the FT here.
										//BuildTree(graph, parent, tree);

										var cell = state.cell;
										if (cell.parentCell)
												cell = cell.parentCell;

										//check to make sure component not already child
										var alreadyExist = false;
										var compChildren;
										var index = -1;
										for (var i = 0; i &lt; graph.sidebar.LogicNodeList.length; i++) {
												if (graph.sidebar.LogicNodeList[i].LogicNode.name == cell.value.name) {
														compChildren = graph.sidebar.LogicNodeList[i].LogicNode.compChildren;
														index = i;
												}
										}
										if (!compChildren) {
												graph.sidebar.LogicNodeList[index].LogicNode.compChildren = [];
										}
										for (var i = 0; i &lt; compChildren.length; i++) {
												if (compChildren[i] == newDiagram.name) {
														alreadyExist = true;
												}
										}
										if (!alreadyExist) {
												AddChildComp(graph, cell, newDiagram);
												graph.sidebar.LogicNodeList[index].LogicNode.compChildren.add(newDiagram.name);
										}
										else {
												alert(newDiagram.name + " is already added to that cell");
										}

								}
								

            //tell the current shape to update itself. Comment this out if the current shape is not require refresh.
            //var pCell = graph.getModel().getParent(state.cell); 
            //var pState = graph.getView().getState(pCell);
            //graph.fireEvent(new mxEventObject(mxEvent.UPDATE_CELL_SIZE, "cell", pCell,"mxImageShape", pState.shape));
          }
						else {
								
								var newID = getDefaultGateID(graph);
								var gateType = evt.dataTransfer.getData("gate");
								var parent = graph.getDefaultParent();
								var vertex = null;
								var cell = state.cell;
								if (cell.parentCell)
										cell = cell.parentCell;
								graph.getModel().beginUpdate();
								if (gateType == "ftBasicEvent") { //if it is a BE gate
									
										addBE(graph, cell);
								}
								else { // if it is a AND/ OR gate
										try {
												
												var ftNode = new FTItem(newID, "gate_" + newID, "", gateType, "Gate", null, null, null);
												ftNode.gateType = gateType;
												vertex = AddChildGate(graph, cell, ftNode);
										}
										finally {
												graph.getModel().endUpdate();
										}

										graph.setSelectionCell(vertex);
										if (cell.value.gateChildren.indexOf("gate_" + newID) &lt; 0)
												cell.value.gateChildren.add("gate_" + newID);
										var newLogicNode = {
												LogicNode: {
														id: newID,
														name: "gate_" + newID,
														desc: "",
														gateType: gateType,
														rootName: cell.value.rootName,
														compChildren: [],
														gateChildren: []
												}
										};
										graph.sidebar.LogicNodeList.add(newLogicNode);
										graph.zoomOut();
										graph.zoomActual();
										graph.zoomOut();
								}
						

						
						}
          evt.preventDefault();
          evt.stopPropagation();

        }.bind(watchEl);
      } //installDropHandler

      oldRedrawLabel.apply(this, arguments); // "supercall"
      if (state.cell.isEdge() == true) return;
      var graph = state.view.graph;
      //var s = graph.view.scale;
     
      if (graph.getModel().isVertex(state.cell) &amp;&amp; state.text != null) {
        if (((state.shape instanceof mxLabel) || (state.shape instanceof mxImageShape))
          &amp;&amp; (typeof (state.cell.value) !== 'string')) {
          if (!state.cell.value) return;
          if (state.cell.value.diagramType) return;  //don't need to drop on leave node.

          // Scrollbars are on the div
          //state.text.node.style.overflow = 'hidden';
          //get the main TableShape panel and should be only one.
          var el = state.text.node.getElementsByTagName('div');
          if (el) {
            if (el.length > 1) el = el[1];
            else if (el.length > 0) el = el[0];
          }
          else el = null;

          if (el != null) {
            el.style.width = '200px';
            el.style.height = '40px';
            //el.style.border = '1px solid red';
           
            installDropHandler(el);
          }
        }
      }

    }
    //Collapse or folding of cells

    //mxGraph.prototype.collapsedImage = new mxImage(mxClient.imageBasePath + '/collapsed.gif', 9, 9);
    //mxGraph.prototype.expandedImage = new mxImage(mxClient.imageBasePath + '/expanded.gif', 9, 9);
    //-------------------------------------------------------------
    // Defines the condition for showing the folding icon
    graph.isCellFoldable = function (cell) {
      return this.model.getOutgoingEdges(cell).length > 0;
    };
    //-------------------------------------------------------------
    // Defines the position of the folding icon
    graph.cellRenderer.getControlBounds = function (state) {
      if (state.control != null) {
        var oldScale = state.control.scale;
        var w = state.control.bounds.width / oldScale;
        var h = state.control.bounds.height / oldScale;
        var s = state.view.scale;
        var g = (Globals.ftNodeSettings.gateImgSize * s) - (9 * s / 2);

        //Globals.ftNodeSettings.height
        return new mxRectangle(state.x + state.width / 2 - w / 2 * s,
          state.y + state.height + g,
          9, 9);
      }

      return null;
    };
    //-------------------------------------------------------------
    // Implements the click on a folding icon
    graph.foldCells = function (collapse, recurse, cells) {
      this.model.beginUpdate();
      try {
        toggleSubtree(this, cells[0], !collapse);
        this.model.setCollapsed(cells[0], collapse);

        // Executes the layout for the new graph since
        // changes to visibility and collapsed state do
        // not trigger a layout in the current manager.
        layout.execute(graph.getDefaultParent());
      }
      finally {
        this.model.endUpdate();
      }
    };
    //-------------------------------------------------------------
    // Updates the visible state of a given subtree taking into
    // account the collapsed state of the traversed branches
    var toggleSubtree = function (graph, cell, show) {
      show = (show != null) ? show : true;
      var cells = [];

      graph.traverse(cell, true, function (vertex) {
        if (vertex != cell) {
          cells.push(vertex);
        }

        // Stops recursion if a collapsed cell is seen
        return vertex == cell || !graph.isCellCollapsed(vertex);
      });

      graph.toggleCells(show, cells, true);
    };
    //end section for collapsing or folding items.


    // Gets the default parent for inserting new cells. This
    // is normally the first child of the root (ie. layer 0).
    var parent = graph.getDefaultParent();
  

    //-------------------------------------------------
    // Main entry point to FT...

			var handleTree = function (tree) {
			graph.tree = tree;
      graph.sidebar = tree.sidebar;
      graph.DiagramList = tree.DiagramList;
      BuildTree(graph, parent, tree);
					graph.fit();
					graph.center();
					graph.zoomIn();
					graph.zoomIn();
					graph.zoomIn();
					graph.zoomIn();
					graph.zoomIn();
			var sb = graph.sidebar;
			//sb.emptyLocalPanels();
    };

    window.mainLoadTree = handleTree;
        
    //--------------------------------------------------
			function reloadGraph(graph) {
					var tree = graph.tree;
					var rootcell = graph.getDefaultParent();
					deleteSubtree(graph, rootcell);
					graph.tree = tree;
					graph.sidebar = tree.sidebar;
					graph.DiagramList = tree.DiagramList;
					BuildTree(graph, null, tree);
					graph.zoomOut();
			}

    //ParseBED('../ftFiles/DEMO.BED', ftNodes);
    //ParseGTD('ftFiles/DEMO.GTD', ftNodes);
    //ParseBEI('ftFiles/DEMO.BEI', ftNodes);
    //ParseFTL(graph, 'ftFiles/DEMO.FTL', ftNodes);

    var content = document.createElement('div');
    content.style.padding = '4px';
    var tb = new FaultTree.Toolbar(content, graph);


    tb.addItem('Zoom In', 'images/zoom_in32.png', function (evt) {
      graph.zoomIn();
    });

    tb.addItem('Zoom Out', 'images/zoom_out32.png', function (evt) {
      graph.zoomOut();
    });

    tb.addItem('Actual Size', 'images/view_1_132.png', function (evt) {
      graph.zoomActual();
    });

    /*tb.addItem('Print', 'images/print32.png', function (evt) {
      var preview = new mxPrintPreview(graph, 1);
      preview.open();
    });*/

    //tb.addItem('Poster Print', 'images/press32.png', function (evt) {
    //  var pageCount = mxUtils.prompt('Enter maximum page count', '1');

    //  if (pageCount != null) {
    //    var scale = mxUtils.getScaleForPageCount(pageCount, graph);
    //    var preview = new mxPrintPreview(graph, scale);
    //    preview.open();
    //  }
    //});
    /*tb.addSeparator('images/Vert.png');
    tb.addItem('Undo', 'images/undo.png', function (evt) {
      editor.execute('undo');
    });

    tb.addItem('Redo', 'images/redo.png', function (evt) {
      editor.execute('redo');
    }); */

    //tb.addItem('Save', 'images/save.png', function (evt) {
    //  SaveFTL(graph, '');
    //});
    //-------------------------------------------------------------
    var dropHandler = function (graph, evt, cell, x, y) {
      if (!cell) return;

      var parent = graph.getDefaultParent();
      var vertex = null;

      graph.getModel().beginUpdate();
      try {
        var gateType = "BE";
        if (evt.toElement.title.indexOf("OR") >= 0)
          gateType = "OR";
        else if (evt.toElement.title.indexOf("AND") >= 0)
          gateType = "AND";

        var ftNode = new FTItem(0, "Untitled", "", gateType, "Gate", null, null, null);
        vertex = AddChild(graph, cell, ftNode);
      }
      finally {
        graph.getModel().endUpdate();
      }

      graph.setSelectionCell(vertex);
    };
    //-------------------------------------------------------------
			tb.addSeparator('images/Vert.png');
			tb.addNewDraggableItem('gtOr', 'images/OrGate.png', null, true);
			tb.addNewDraggableItem('gtAnd', 'images/AndGate.png', null, true);
			tb.addNewDraggableItem('ftBasicEvent', 'images/BE.png', null, true);
    //tb.addDraggableItem('OR State', 'images/OrGate.png', null, true, dropHandler);
    //tb.addDraggableItem('AND State', 'images/AndGate.png', null, true, dropHandler);
    //tb.addDraggableItem('BE Event', 'images/BE.png', null, true, dropHandler);
		tb.addSeparator('images/Vert.png');
		tb.addItem('Help', 'images/question.png', function (evt) {
				
		var url = "HelpLogicTree.html";
		var componentDiagrams = [];
		mxWindow.createFrameWindow(
				url,
				'OK',  //command buttons
				'minimize, maximize, close', //top buttons
				function (btn, retObj) {
						return true;
				},
				componentDiagrams,
				true, //ismodal
				null,
				null,
				450, //width
				200 //height
		);

			});
    var wnd = new mxWindow('Tools', content, 0, 0, null, null, false);
    wnd.setMaximizable(false);
    wnd.setScrollable(false);
    //wnd.setResizable(false);
    wnd.setVisible(true);


    // Fades-out the splash screen after the UI has been loaded.
    var splash = document.getElementById('splash');
    if (splash != null) {
      try {
        mxEvent.release(splash);
        mxEffects.fadeOut(splash, 100, true);
      }
      catch (e) {

        // mxUtils is not available (library not loaded)
        splash.parentNode.removeChild(splash);
      }
    }
    //-------------------------------------------------------------
  }
}

/**
 * Creates entries in the popup menu.
 * 
 * @param {mxGraph} graph The main mxGraph.
 * @param {*} menu The popup menu.
 * @param {mxCell} cell The menu cell.
 * @param {mxEvent} evt The click event.
 */
var createPopupMenu = function (graph, menu, cell, evt) {
  var model = graph.getModel();

  if (cell != null) {
    if (model.isVertex(cell)) {
      menu.addItem('Add child', 'images/overlays/check.png', function () {
        AddChild(graph, cell);
      });
    }

    menu.addItem('Edit label', 'images/text.gif', function () {
      graph.startEditingAtCell(cell);
    });

    if (cell.id != 'treeRoot' &amp;&amp; model.isVertex(cell)) {
      menu.addItem('Delete', 'images/delete.gif', function () {
        deleteSubtree(graph, cell);
      });
    }

		if (cell.id != 'treeRoot' &amp;&amp;
            model.isVertex(cell)) {
      menu.addItem('add', 'images/add.png', function () {
					alert("TODO");
      });
    }

    menu.addSeparator();
  }

  menu.addItem('Fit', 'images/zoom.gif', function () {
    graph.fit();
  });

  menu.addItem('Actual', 'images/zoomactual.gif', function () {
    graph.zoomActual();
  });

  menu.addSeparator();

  /*menu.addItem('Print', 'images/print.gif', function () {
    var preview = new mxPrintPreview(graph, 1);
    preview.open();
  });

  menu.addItem('Poster Print', 'images/print.gif', function () {
    var pageCount = mxUtils.prompt('Enter maximum page count', '1');

    if (pageCount != null) {
      var scale = mxUtils.getScaleForPageCount(pageCount, graph);
      var preview = new mxPrintPreview(graph, scale);
      preview.open();
    }
  });*/
}
;

/**
 * Gets the next available gate ID.
 * 
 * @param {mxGraph} graph The main mxGraph.
 * @returns {number} The next available gate ID.
 */
function getDefaultGateID(graph) {
		var maxID = 0;
		var logicNodeList = graph.sidebar.LogicNodeList;
		for (var i = 0; i &lt; logicNodeList.length; i++) {
				if (logicNodeList[i].LogicNode.id > maxID) {
						maxID = logicNodeList[i].LogicNode.id;
				}
		}
		return (maxID + 1);
}

/**
 * Adds overlay images to the graph.
 * 
 * @param {mxGraph} graph The main mxGraph.
 * @param {mxCell} cell The target mxCell.
 * @param {boolean} [isEditable] Adds editing overlays to the cell.
 */
function addOverlays(graph, cell, isEditable) {
  var overlay = new mxCellOverlay(new mxImage('images/delete.png', 16, 16), 'delete');
  overlay.cursor = 'hand';
  overlay.offset = new mxPoint(-6, 4);//(-4, 8);
  overlay.align = mxConstants.ALIGN_RIGHT;
  overlay.verticalAlign = mxConstants.ALIGN_BOTTOM;
  overlay.addListener(mxEvent.CLICK, function (sender, evt) {
    deleteSubtree(graph, cell);
  }.bind(this));

  graph.addCellOverlay(cell, overlay);


  if (isEditable) {
    overlay = new mxCellOverlay(new mxImage('images/edit.png', 16, 16), 'Edit');
    overlay.cursor = 'hand';
    overlay.offset = new mxPoint(-26, 4);//(-4, 8);
    overlay.align = mxConstants.ALIGN_RIGHT;
    overlay.verticalAlign = mxConstants.ALIGN_BOTTOM;
    overlay.addListener(mxEvent.CLICK, function (sender, evt) {
      if (cell.value) {
          if (cell.value.diagramType)
              editDiagramNode(graph, cell);
          else if (cell.value.gateType)
              editNode(graph, cell);
      }
      else if (cell.nameItem &amp;&amp; cell.nameItem.value.diagramType)
        editDiagramNode(graph, cell.nameItem);
    });

    graph.addCellOverlay(cell, overlay);
  }
		if (cell.style == "ftGate;" ) {
			overlay = new mxCellOverlay(new mxImage('images/add.png', 16, 16), 'add');
			overlay.cursor = 'hand';
			overlay.offset = new mxPoint(6, 4);//(-4, 8);
			overlay.align = mxConstants.ALIGN_LEFT;
			overlay.verticalAlign = mxConstants.ALIGN_BOTTOM;
			overlay.addListener(mxEvent.CLICK, function (sender, evt) {
					if (cell.value) {
							if (cell.value.gateType)
									addNode(graph, cell);
					}
			});

			graph.addCellOverlay(cell, overlay);
    }

}

/**
 * Merges two fault trees.
 * 
 * @param {object} obj1 Fault tree A.
 * @param {object} obj2 Fault tree B.
 */
function mergeFTData(obj1, obj2) {
  for (var attrname in obj2) { obj1[attrname] = obj2[attrname]; }
}

/**
 * Updates the overlay cells when a state is edited.
 * 
 * @param {mxGraph} graph The main mxGraph.
 * @param {mxCell} cell The target mxCell.
 */
function updateCell(graph, cell) {

   

		graph.labelChanged(cell, cell.value, this);
//Not sure what the intention was of this??
/*
    //Rebuild the graph - not the most efficient way but it works
    deleteSubtree(graph, cell);
    var GetFTItem = function (cell) {
        if (cell instanceof mxCell) {
            if (cell.children == null) {
                return null;
            }

            for (var i = 0; i &lt; cell.children.length; i++) {
                var cellVal = cell.children[i].value;
                if ((cellVal != null) &amp;&amp; (cellVal instanceof FTItem)) {
                    return cellVal;
                }
            }
        }

        return null;
    }
    graph.gateChanged(cell, cell.value, this);
    //aState = graph.view.getState(cell.descItem);
    //if (aState) graph.cellRenderer.redraw(aState);
			//	AddChildGate(graph, parent, GetFTItem)
    //BuildTree(graph, parent, tree);
   
*/

 
 
}

/**
 * Builds a tree.
 * 
 * @param {mxGraph} graph The main mxGraph.
 * @param {mxCell} parentCell The parent mxCell.
 * @param {LogicNode} node The tree logic node.
 */
function BuildTreeRec(graph, parentCell, node) {
    if (node != undefined) {
        if (parentCell == null)
            var addedChild = AddChildGate(graph, parent, node.LogicNode);
        else
            var addedChild = AddChildGate(graph, parentCell, node.LogicNode);

        //addedChild.value = node.LogicNode;
        if (node.gateChildren != undefined) {
            for (var i = 0; i &lt; node.gateChildren.length; i++) {
                BuildTreeRec(addedChild, node.gateChildren[i].LogicNode);
            }
        }

        if (node.compChildren != undefined) {
            for (var i = 0; i &lt; node.compChildren.length; i++) {
                AddChildComp(graph, addedChild, node.compChildren[i]);
            }
        }
    }
}

/**
 * Edits a diagram node.
 * 
 * @param {mxGraph} graph The main mxGraph.
 * @param {mxCell} cell The diagram cell.
 */
function editDiagramNode(graph, cell) {
  var sb = graph.sidebar;
  //var ds = graph.DiagramList;

  var diagram = cell.value;
  //for (var i = 0; i &lt; ds.length; i++) {
  //  if (ds[i].Diagram.name == cell.id) {
  //    diagram = ds[i].Diagram;
  //    break;
  //  }
  //}

  if (diagram)
    sb.openDiagramWindow(diagram);

}

/*
 //TODO change this to be like the rest
function editNode(graph, cell) {
  mxWindow.createFrameWindow(
  'EditForms/GateEditor.html',
  'Save, Cancel',  //command buttons
  'minimize, maximize, close', //top buttons
  function (btn, dataObj) {
    if (btn === 'Save') {
      mergeFTData(cell.value, dataObj);
      var state = graph.getView().getState(cell);
      updateCell(graph, cell);
    }
    return true;
  },
  cell.value,
  true, //ismodal
  null,
  null,
  450, //width
  300 //height
  );

}

*/


/**
 * Edits a node in the graph.
 * 
 * @param {mxGraph} graph The main mxGraph.
 * @param {mxCell} stateCell The state cell.
 */
function editNode (graph, stateCell) {
    var url = "EditForms/GateEditor.html";
		var sModel = stateCell.value;
		var oldName = stateCell.value.name;
    mxWindow.createFrameWindow(
        url,
        'OK, Cancel',  //command buttons
        'minimize, maximize, close', //top buttons
        function (btn, retObj) {
            if (btn === 'OK') {
								var logicNodeList = graph.sidebar.LogicNodeList;
								for (var i = 0; i &lt; logicNodeList.length; i++) {
										if (logicNodeList[i].LogicNode.name == oldName) {
                      graph.sidebar.LogicNodeList[i].LogicNode.desc = retObj.desc;
                      graph.sidebar.LogicNodeList[i].LogicNode.gateType = retObj.gateType;
										}
										var gateChildren = logicNodeList[i].LogicNode.gateChildren;
										if (gateChildren) {
												for (var j = 0; j &lt; gateChildren.length; j++) {
														if (gateChildren[j] == oldName) {
																graph.sidebar.LogicNodeList[i].LogicNode.gateChildren[j] = retObj.name;
														}
												}
										}
								}
								mergeFTData(stateCell.value, retObj);
								var state = graph.getView().getState(stateCell);
								updateCell(graph, stateCell);
            }
            return true;
        },
        sModel,
        true, //ismodal
        null,
        null,
        450, //width
        300 //height
    );
}

/**
 * Adds a node to the graph.
 * 
 * @param {mxGraph} graph The main mxGraph.
 * @param {mxCell} stateCell The cell to add to.
 */
function addNode(graph, stateCell) {
		var url = "EditForms/GateAdder.html";
		var componentDiagrams = [];
		var diagramList = graph.sidebar.DiagramList;
		for (var i = 0; i &lt; diagramList.length; i++) {
				if (diagramList[i].Diagram.diagramType == "dtComponent") {
						var obj = diagramList[i].Diagram;
						componentDiagrams.add(obj);
						//TODO: do not add diagrams that already exist
				}
		}
		mxWindow.createFrameWindow(
				url,
				'OK, Cancel',  //command buttons
				'minimize, maximize, close', //top buttons
				function (btn, retObj) {
						if (btn === 'OK') {
								if (retObj.addType == "diagram" &amp;&amp; retObj.newDiagram ) {
										var state = graph.getView().getState(stateCell);
										var cell = state.cell;
										if (cell.parentCell)
												cell = cell.parentCell;
										//check to make sure component not already child
										var alreadyExist = false;
										var compChildren;
										var index = -1;
										for (var i = 0; i &lt; graph.sidebar.LogicNodeList.length; i++) {
												if (graph.sidebar.LogicNodeList[i].LogicNode.name == cell.value.name) {
														compChildren = graph.sidebar.LogicNodeList[i].LogicNode.compChildren;
														index = i;
												}
										}
										for (var i = 0; i &lt; compChildren.length; i++) {
												if (compChildren[i] == retObj.newDiagram.name) {
														alreadyExist = true;
												}
										}
										if (!alreadyExist) {
												AddChildComp(graph, cell, retObj.newDiagram);
												graph.sidebar.LogicNodeList[index].LogicNode.compChildren.add(retObj.newDiagram.name);
										}
										else {
												alert(retObj.newDiagram.name + " is already added to that cell");
										}
								}
								else if (retObj.addType == "standard") {
										//check to make sure component not already child
										var alreadyExist = false;
										var vertex = null;
										var state = graph.getView().getState(stateCell);
										var cell = state.cell;
										var newID = getDefaultGateID(graph);
										for (var i = 0; i &lt; graph.sidebar.LogicNodeList.length; i++) {
												if (graph.sidebar.LogicNodeList[i].LogicNode.name == retObj.newName) {
														alreadyExist = true;
												}
										}
										if (!alreadyExist) {
												graph.getModel().beginUpdate();
												try {
														var ftNode = new FTItem(newID, retObj.newName, retObj.newDesc, retObj.newGateType, "Gate", null, null, null);
														ftNode.gateType = retObj.newGateType;
														vertex = AddChildGate(graph, cell, ftNode);
												}
												finally {
														graph.getModel().endUpdate();
												}

												graph.setSelectionCell(vertex);
												for (var i = 0; i &lt; graph.sidebar.LogicNodeList.length; i++) {
														if (graph.sidebar.LogicNodeList[i].LogicNode.name == cell.value.name) {
																if (graph.sidebar.LogicNodeList[i].LogicNode.gateChildren.indexOf(retObj.newName) &lt; 0)
																		graph.sidebar.LogicNodeList[i].LogicNode.gateChildren.add(retObj.newName);
														}
												}

												var newLogicNode = {
														LogicNode: {
																id: newID,
																name: retObj.newName,
																desc: retObj.newDesc,
																gateType: retObj.newGateType,
																"rootName": cell.value.rootName,
																"compChildren": [],
																"gateChildren": []
														}
												};
												graph.sidebar.LogicNodeList.add(newLogicNode);
												graph.zoomActual();
												graph.zoomOut();

										}
										else {
												alert(retObj.newName + " is already added to that cell");
										}
										
								}

						}
						return true;
				},
				componentDiagrams,
				true, //ismodal
				null,
				null,
				500, //width
				250 //height
		);
}


/**
 * Adds a basic event to the graph.
 * 
 * @param {mxGraph} graph The main mxGraph.
 * @param {mxCell} cell The cell to add to.
 */
function addBE(graph, cell) {
		var url = "EditForms/CompAdder.html";
		var componentDiagrams = [];
		var diagramList = graph.sidebar.DiagramList;
		for (var i = 0; i &lt; diagramList.length; i++) {
				if (diagramList[i].Diagram.diagramType == "dtComponent") {
						var obj = diagramList[i].Diagram;
						componentDiagrams.add(obj);
						//TODO: do not add diagrams that already exist
				}
		}
		mxWindow.createFrameWindow(
				url,
				'OK, Cancel',  //command buttons
				'minimize, maximize, close', //top buttons
				function (btn, retObj) {
						if (btn === 'OK') {
										//check to make sure component not already child
								var alreadyExist = false;
								var compChildren;
								var newDiagram = retObj.element;
								var index = -1;
								for (var i = 0; i &lt; graph.sidebar.LogicNodeList.length; i++) {
										if (graph.sidebar.LogicNodeList[i].LogicNode.name == cell.value.name) {
												compChildren = graph.sidebar.LogicNodeList[i].LogicNode.compChildren;
												index = i;
										}
								}
								if (!compChildren) {
										graph.sidebar.LogicNodeList[index].LogicNode.compChildren = [];
								}
								for (var i = 0; i &lt; compChildren.length; i++) {
										if (compChildren[i] == newDiagram.name) {
												alreadyExist = true;
										}
								}
								if (!alreadyExist) {
										AddChildComp(graph, cell, newDiagram);
										graph.sidebar.LogicNodeList[index].LogicNode.compChildren.add(newDiagram.name);
								}
								else {
										alert(newDiagram.name + " is already added to that cell");
              }
              graph.getModel().endUpdate();

						}
						return true;

				},
				componentDiagrams,
				true, //ismodal
				null,
				null,
				450, //width
				200 //height
		);
}



//TODO
/**
 * Displays an error message.
 * 
 * @param {string} message The message to display.
 */
function ErrorMessage(message) {

}






//Patches

mxLayoutManager.prototype.getCellsForChange = function (change) {
  var model = this.getGraph().getModel();

  if (change instanceof mxChildChange) {
    return [change.child, change.previous, model.getParent(change.child)];
  }
  else if (change instanceof mxTerminalChange || change instanceof mxGeometryChange) {
    return [change.cell, model.getParent(change.cell)];
  }
  else if (change instanceof mxVisibleChange || change instanceof mxStyleChange) {
    return [change.cell];
  }

  return [];
};


//Override to not allow individual overlay cells to be deleted.
var graphRemoveCells = mxGraph.prototype.removeCells;
mxGraph.prototype.removeCells = function (cells, includeEdges) {
  if (!cells) {
    cells = this.getDeletableCells(this.getSelectionCells());
  }

  var i = 0;
  while (i &lt; cells.length) {
    var cell = cells[i];
    if (!(cell.value instanceof FTItem) &amp;&amp; (!cell.forceDelete)) {
      cells.splice(i, 1);
    }
    else
      ++i;
  }
  return graphRemoveCells.apply(this, [cells, true]);
};

//override to not allow an edge to be selected.  If edge allows to be selected, it can be deleted, moved and disconnect form state.
mxGraph.prototype.isCellSelectable = function (cell) {
  if (cell.isEdge())
    return false;
  else
    return this.isCellsSelectable();
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="FaultTree.html">FaultTree</a></li><li><a href="ftEditor.html">ftEditor</a></li><li><a href="Navigation.html">Navigation</a></li><li><a href="RiskSim.html">RiskSim</a></li><li><a href="simApp.html">simApp</a></li></ul><h3>Classes</h3><ul><li><a href="Enum.html">Enum</a></li><li><a href="FaultTree_Toolbar.html">Toolbar</a></li><li><a href="ftEditor_FTItem.html">FTItem</a></li><li><a href="ftEditor_FTItemArray.html">FTItemArray</a></li><li><a href="Navigation_Menu.html">Menu</a></li><li><a href="Navigation_Sidebar.html">Sidebar</a></li><li><a href="RiskSim_CommonDialog.html">CommonDialog</a></li><li><a href="RiskSim_Window.html">Window</a></li><li><a href="simApp_SimApp.html">SimApp</a></li><li><a href="StateApp.html">StateApp</a></li><li><a href="StateShape.html">StateShape</a></li><li><a href="TableShape.html">TableShape</a></li><li><a href="WcfService.html">WcfService</a></li><li><a href="WindowFrame.html">WindowFrame</a></li></ul><h3>Interfaces</h3><ul><li><a href="Action.html">Action</a></li><li><a href="Diagram.html">Diagram</a></li><li><a href="Event.html">Event</a></li><li><a href="ExtSim.html">ExtSim</a></li><li><a href="ftEditor_Globals.html">Globals</a></li><li><a href="ftEditor_Globals_ftNodeSettings.html">ftNodeSettings</a></li><li><a href="LogicNode.html">LogicNode</a></li><li><a href="MenuItem.html">MenuItem</a></li><li><a href="Model.html">Model</a></li><li><a href="State.html">State</a></li><li><a href="Variable.html">Variable</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addBE">addBE</a></li><li><a href="global.html#addNode">addNode</a></li><li><a href="global.html#addOverlays">addOverlays</a></li><li><a href="global.html#adjustWindowPos">adjustWindowPos</a></li><li><a href="global.html#BuildTreeRec">BuildTreeRec</a></li><li><a href="global.html#classNameOf">classNameOf</a></li><li><a href="global.html#clearAllCookies">clearAllCookies</a></li><li><a href="global.html#createDemo">createDemo</a></li><li><a href="global.html#createPopupMenu">createPopupMenu</a></li><li><a href="global.html#createTestProject">createTestProject</a></li><li><a href="global.html#createTestProject2">createTestProject2</a></li><li><a href="global.html#DataChanged">DataChanged</a></li><li><a href="global.html#DataType">DataType</a></li><li><a href="global.html#deepClone">deepClone</a></li><li><a href="global.html#deleteSimulation">deleteSimulation</a></li><li><a href="global.html#downloadClientTester">downloadClientTester</a></li><li><a href="global.html#downloadClientTesterSource">downloadClientTesterSource</a></li><li><a href="global.html#downloadSolver">downloadSolver</a></li><li><a href="global.html#editDiagramNode">editDiagramNode</a></li><li><a href="global.html#editNode">editNode</a></li><li><a href="global.html#ErrorMessage">ErrorMessage</a></li><li><a href="global.html#extractSubStr">extractSubStr</a></li><li><a href="global.html#GetDataObject">GetDataObject</a></li><li><a href="global.html#getDefaultGateID">getDefaultGateID</a></li><li><a href="global.html#getMainApp">getMainApp</a></li><li><a href="global.html#getRowY">getRowY</a></li><li><a href="global.html#getServerFile">getServerFile</a></li><li><a href="global.html#getSidebar">getSidebar</a></li><li><a href="global.html#isIENavigator">isIENavigator</a></li><li><a href="global.html#isModified">isModified</a></li><li><a href="global.html#main">main</a></li><li><a href="global.html#makeTransparent">makeTransparent</a></li><li><a href="global.html#mergeFTData">mergeFTData</a></li><li><a href="global.html#mergeIntoCurrentProject">mergeIntoCurrentProject</a></li><li><a href="global.html#MessageBox">MessageBox</a></li><li><a href="global.html#newProject">newProject</a></li><li><a href="global.html#newSimulation">newSimulation</a></li><li><a href="global.html#noSpaces">noSpaces</a></li><li><a href="global.html#OnLoad">OnLoad</a></li><li><a href="global.html#OnSave">OnSave</a></li><li><a href="global.html#openAbout">openAbout</a></li><li><a href="global.html#openCSharpTool">openCSharpTool</a></li><li><a href="global.html#openFaultTree">openFaultTree</a></li><li><a href="global.html#openHelp">openHelp</a></li><li><a href="global.html#openProject">openProject</a></li><li><a href="global.html#openPythonTool">openPythonTool</a></li><li><a href="global.html#rgba">rgba</a></li><li><a href="global.html#route">route</a></li><li><a href="global.html#saveDiagramProperties">saveDiagramProperties</a></li><li><a href="global.html#saveProject">saveProject</a></li><li><a href="global.html#saveTemplate">saveTemplate</a></li><li><a href="global.html#sequence">sequence</a></li><li><a href="global.html#setCookie">setCookie</a></li><li><a href="global.html#setModified">setModified</a></li><li><a href="global.html#SetOf">SetOf</a></li><li><a href="global.html#somethingChanged">somethingChanged</a></li><li><a href="global.html#sortDOMList">sortDOMList</a></li><li><a href="global.html#testMakeCompDiagram">testMakeCompDiagram</a></li><li><a href="global.html#triggerEvent">triggerEvent</a></li><li><a href="global.html#updateCell">updateCell</a></li><li><a href="global.html#ValidateData">ValidateData</a></li><li><a href="global.html#waitToSync">waitToSync</a></li><li><a href="global.html#windowClosing">windowClosing</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Mon Aug 02 2021 17:12:21 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
