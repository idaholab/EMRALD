import{_ as e,c as t,o as a,a2 as s}from"./chunks/framework.BLHWSx9w.js";const i="/assets/XMPP_logo.CCdwmrqM.png",n="/assets/ActionMessage.B1Wdl0vL.png",o="/assets/EventMessage.DJ5zZr2x.png",r="/assets/XMPP_Msg_StateDiagram.DvIxmtsn.png",l="/assets/SequenceDiagram.B8WTspvi.png",h="/assets/SolveEngineExtLink.FwBP0Vsp.png",c="/assets/SolveEngineSelLink.Cogmq42Y.png",m="/assets/SolveEngineMsgLog.DUs12uNx.png",d="/assets/SolveEngineMsgBuilder.C1G_MmXr.png",u="/assets/SolveEngineMsgBuilderBtm.D3bnEgqn.png",p="/assets/SolveEngineMsgBuilderAuto.DQlPut-j.png",g="/assets/ClentTesterMain.CaM5Bv_7.png",f="/assets/ClentTesterMsgArea.Jxu3QHTs.png",b="/assets/ClientMsglog.BFJlQkwE.png",P=JSON.parse('{"title":"External Couping using XMPP","description":"","frontmatter":{},"headers":[],"relativePath":"Modeling/xmppProtocol.md","filePath":"Modeling/xmppProtocol.md"}'),w={name:"Modeling/xmppProtocol.md"},M=s('<h1 id="external-couping-using-xmpp" tabindex="-1">External Couping using XMPP <a class="header-anchor" href="#external-couping-using-xmpp" aria-label="Permalink to &quot;External Couping using XMPP&quot;">​</a></h1><p>!<div style="width:300px;"><img src="'+i+'" alt="logo"></div><br></p><h1 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h1><p>The XMPP message passing protocol in EMRALD makes it possible to do two-way coupling where the events in another simulation affect what happens in the EMRALD model and the events in the EMRALD model can change the other simulation, all in real time. To do this, you must either have access to the source of the coupling simulation or write a wrapper for an API of the other application. This section covers the message structure and minimum requirements. Notice - This is feature is still in beta development and subject to change.</p><h2 id="xmpp-protocol" tabindex="-1">XMPP Protocol <a class="header-anchor" href="#xmpp-protocol" aria-label="Permalink to &quot;XMPP Protocol&quot;">​</a></h2><p>For XMPP message passing a server is used to send messages from one client to another. The server handles a the message authentication and send/receive verification. EMRALD has a built in XMPP Server and automatically runs it if the model contains a reference to and external application. See <a href="/Modeling/externalSims.html">External Simulations</a>. To couple with another application requires some software development, you must add an XMPP package suitable for the source code of the application or write a wrapper that is able to handle the message requirements and call the applications API.</p><h2 id="linking-process" tabindex="-1">Linking Process <a class="header-anchor" href="#linking-process" aria-label="Permalink to &quot;Linking Process&quot;">​</a></h2><p>When opening an EMRALD model with containing a reference to and external application, you must establish a connection to that application before you can run the model, see <a href="#linking-process">Linking Process</a>. Every message specified in EMRALD for that reference will be sent to the assigned XMPP connection and for each event received from that application EMRALD will see if the name matches a linked variable specified for it. If there is a match, that variable will be updated with the value from the event.</p><h1 id="message-requirements" tabindex="-1">Message Requirements <a class="header-anchor" href="#message-requirements" aria-label="Permalink to &quot;Message Requirements&quot;">​</a></h1><p>The following outlines what is used to connect, the messages passed between EMRALD and the simulation client, and a recommendation on the structure for processing and sending messages.</p><h2 id="connecting" tabindex="-1">Connecting <a class="header-anchor" href="#connecting" aria-label="Permalink to &quot;Connecting&quot;">​</a></h2><p>The connection parameters for linking to the XMPP server are as following: User - unique identifier for the external application. If more than one application is linked to EMRALD each must have a different user. Domain - the domain location where EMRALD is running from typically this will stay as &quot;localhost&quot; when running on a single machine. If on EMRALD is on a different machine then this is the IP address of the machine running EMRALD. Host - currently a constant set to &quot;localhost&quot; Resource - This is the connection group for the messaging. When EMRALD feature allows multiprocessing, there will need to be multiple instances of the external application with incremental values for each thread. Password - Default is &quot;secret&quot; this can be assigned in EMRALD when starting up through command line. Run -help after the EXE to see command line options.</p><h2 id="message-format" tabindex="-1">Message Format <a class="header-anchor" href="#message-format" aria-label="Permalink to &quot;Message Format&quot;">​</a></h2><p>The messages are in JSON format and there are two types of messages: Action Messages - messages from EMRALD for the client to do something with. Event Messages - messages from the client that EMRALD needs to respond to. The message format can be found in c# format under the MessageDeffLib project in MsgWrapper.cs a schema to test against is found in MessageProtocol.json. The following sections go over the different varibles and types for the messages.</p><p><strong>Action Message Example</strong></p><p><img src="'+n+'" alt="Action Message"><br></p><p><strong>Event Message Example</strong></p><p><img src="'+o+'" alt="Event Message"><br></p><h2 id="action-message-types-from-emrald" tabindex="-1">Action Message Types - From EMRALD <a class="header-anchor" href="#action-message-types-from-emrald" aria-label="Permalink to &quot;Action Message Types - From EMRALD&quot;">​</a></h2><p>The following are the messages that EMRALD may send to the coupled simulation client. The type will be sent as text in the JSON but can be used as an enumerated type (prefixed with &quot;at&quot; meaning Action Type)</p><ul><li><p><strong>atCompModify</strong> - This message is specifying that a particular item is to be modified in the coupled simulation. Modified can also mean created or deleted depending on predetermined agreement between the coupled simulation design and the modeler. on what data in the message means. The data in the message is specified by the coupled simulation specifications and the user making the EMRALD model must follow those specifications.</p></li><li><p><strong>atTimer</strong> - Informs the coupled simulation of the next time that a change needs to occur in EMRALD. This is a callback timer that the coupled application must respond with an etTimer message and wait for a response when its simulation reaches this global time.</p></li><li><p><strong>atOpenSim</strong> - Specifies a model to open and the startup parameters.</p></li><li><p><strong>atCancelSim</strong> - Tells the coupled application to stop the current simulation.</p></li><li><p><strong>atPauseSim</strong> - Pause the current simulation (For future multiple coupled simulations, not currently in use)</p></li><li><p><strong>atContinue</strong> - Tells the application to continue the simulation EMRALD is done on its side.</p></li><li><p><strong>atRestartAtTime</strong> - Specifies time for the application to backup to in its simulation. (For future multiple coupled simulations, not currently in use)</p></li><li><p><strong>atPing</strong> - A user debug message only, this is intended to just verify that an XMPP connection is established.</p></li><li><p><strong>atStatus</strong> - A user debug message only, this is asking the running status state and any current info to help the user determine what is happening in the coupled simulation.</p></li><li><p><strong>atTerminate</strong> - EMRALD is done running its simulations and is shutting down, the coupled application should do the same.</p></li></ul><h2 id="event-message-types-from-client" tabindex="-1">Event Message Types - From Client <a class="header-anchor" href="#event-message-types-from-client" aria-label="Permalink to &quot;Event Message Types - From Client&quot;">​</a></h2><p>The following messages are what can come from the coupled application. The type must be sent as text in the JSON but can be stored however desired. (The messages are prefixed with a &quot;et&quot; meaning Event Type)</p><ul><li><p><strong>etCompEv</strong> - A component or item in the coupled application simulation has changed, and this passes the new value information.</p></li><li><p><strong>etTimer</strong> - An EMRALD callback timer has been reached in coupled application.</p></li><li><p><strong>etSimLoaded</strong> - Tells EMRALD the simulation is ready to start.</p></li><li><p><strong>etEndSim</strong> - Tells EMRALD the simulation is complete either because of internal conditions, or the max time specified my user was reached.</p></li><li><p><strong>etPing</strong> - Repose to a ping from EMRALD.</p></li><li><p><strong>etStatus</strong> - This message can be sent at any time by the coupled simulation. It must be sent in response to a atStatus message. A message type of stError will cause EMRALD to end its simulation.</p></li></ul><h2 id="status-states" tabindex="-1">Status States <a class="header-anchor" href="#status-states" aria-label="Permalink to &quot;Status States&quot;">​</a></h2><p>Status message return types is to be sent to EMRALD whenever an atStatus message is received. These should also be used to maintain the current state of the connected application, see the next section.</p><ul><li><strong>stWaiting</strong> - coupled simulation is waiting for what to do next from EMRALD.</li><li><strong>stLoading</strong> - loading after an atOpenSim.</li><li><strong>stRunning</strong> - executing the coupled simulation code, should also have info on what it is doing to help debug.</li><li><strong>stIdle</strong> - initial startup condition or after done running a simulation.</li><li><strong>stError</strong> - an error on the coupled side, that makes it unable to continue. Should contain additional detail on the cause of the error.</li></ul><h2 id="suggested-execution-flow" tabindex="-1">Suggested Execution Flow <a class="header-anchor" href="#suggested-execution-flow" aria-label="Permalink to &quot;Suggested Execution Flow&quot;">​</a></h2><p>The client application needs to maintain the following variables:</p><p><strong>SimTime</strong> - measure the chronology of the client simulation time, starting from zero seconds when it begins at the first atContinue message from EMRALD. The &quot;time&quot; value in the messages is the EMRALD global time from the begining of the EMRALD simulation.</p><p><strong>CallbackTime</strong> - is the EMRALD global time at which the coupled application must pause and return control to EMRALD if no significant event happens sooner.</p><p><strong>CallbackItem</strong> - save the itemData (name, value) given when an atTimer message is sent. Must provide the name and value when sending a etTimer message at the callback time.</p><p><strong>EndTime</strong> - the maximum local time, to guard against runaway simulations, at which AVERT must terminate its simulation. This is specified by the user and passed in on open.</p><p><strong>StartTimeDiff</strong> - is the difference between EMRALD global time and AVERT&#39;s SimTime.</p><p><strong>Status</strong> - indicates the state of coupled interaction with EMRALD.</p><p>It is suggested to use the following flow method for processing and replying to messages. The coupled application should shift through a the status states depending on what messages it receives and what happens in its simulation. This outlines the messages that the application will get given the different states it is in, what it should do and the response messages that should be sent. It is recommended that a status message be sent to EMRALD for each change in status state, to assist in debugging. Also any message received that is not in line with what was expected should also be sent as an error when in a debug version of the code.</p><h3 id="in-any-status-state" tabindex="-1">[In any Status state] <a class="header-anchor" href="#in-any-status-state" aria-label="Permalink to &quot;[In any Status state]&quot;">​</a></h3><p>Note - A stStatus message can be sent from the coupled application at any time. If an Error message is sent EMRALD will stop operations as soon as it can.</p><p><strong>atPing</strong></p><ul><li>Respond with etPing message with a time of (SimTime + StartTimeDiff).</li><li>Stay in current status state.</li></ul><p><strong>atStatus</strong></p><ul><li>Reply with etStatus current status state and time of (SimTime + StartTimeDiff).</li><li>Stay in current status state.</li></ul><h3 id="stidle" tabindex="-1">stIdle <a class="header-anchor" href="#stidle" aria-label="Permalink to &quot;stIdle&quot;">​</a></h3><p>Initial startup condition or after done running a simulation.</p><p><strong>atSimOpen</strong></p><ul><li>Set EndTime to endTime property of the message</li><li>Set StartTimeDiff to the EMRALD global time in the message.</li><li>Clear any temporary data/results</li><li>Shift Status state to stLoaded.</li></ul><p><strong>atTerminate</strong></p><ul><li>Clear any temporary data/results</li><li>Shut down application and any associated threads.</li></ul><h3 id="stloading" tabindex="-1">stLoading <a class="header-anchor" href="#stloading" aria-label="Permalink to &quot;stLoading&quot;">​</a></h3><p>Coupled application is loading after an atSimOpen status state.</p><ul><li>Load the specified model. (For efficiency, application must determine if it is the same model and if it can simply reset the model back to the beginning, reinitializing the data)</li><li>If the model is not found or if loading fails, send atStatus with type atError to EMRALD, including a description of the problem, and shift to stError state.</li><li>If the model loaded correctly, send etSimLoaded message to EMRALD.</li><li>If the model loaded correctly, shift to stWaiting.</li></ul><h3 id="stwaiting" tabindex="-1">stWaiting <a class="header-anchor" href="#stwaiting" aria-label="Permalink to &quot;stWaiting&quot;">​</a></h3><p>In this status state the coupled application is poised to simulate, but is waiting to allow EMRALD to alter the conditions that affect its simulation. This status state is entered from stLoaded, or stRunning once complete.</p><p><strong>atCompModify</strong></p><ul><li>Make or save the change in the model to the parameter and global time specified in the message.</li></ul><p><strong>atTimer</strong></p><ul><li>Set CallBackTime to the time parameter in the atTimer() message.</li><li>Save the CallbackItem data, name and value, to pass back when timer is reached</li></ul><p><strong>atContinue</strong></p><ul><li>Shift to status state of stRunning.</li></ul><p><strong>atCancelSim</strong></p><ul><li>Save current results</li><li>Stop simulation</li><li>Send etEndSim message with time of (SimTime + StartTimeDiff).</li><li>Shift to status state of stIdle.</li></ul><h3 id="strunning" tabindex="-1">stRunning <a class="header-anchor" href="#strunning" aria-label="Permalink to &quot;stRunning&quot;">​</a></h3><p>This is the active execution state for the coupled simulation, advancing time on its side. No events should affect the simulation when in the running state, it only stops on the following conditions: If SimTime + StartTimeDiff &gt;= EndTime or if the simulation naturally terminates due to internal settings/conditions.</p><ul><li>Stop the coupled simulation.</li><li>Save current results</li><li>Send etEndSim message</li><li>Shift to stDone status state</li></ul><p>If SimTime &gt;= CallbackTime</p><ul><li>Pause the coupled simulation.</li><li>Send etTimer message with the name of CallbackName and the time of (SimTime + StartTimeDiff);</li><li>Shift to stWaiting status state.</li></ul><h3 id="stdone" tabindex="-1">stDone <a class="header-anchor" href="#stdone" aria-label="Permalink to &quot;stDone&quot;">​</a></h3><p>Coupled simulation is done and results have been saved just waiting for EMRALD to be done with the results and this run. Got there from an atCancelSim in stWaiting or from stRunning after application sends an etEndSim message. <strong>atContinue</strong></p><ul><li>Shift to stIdle state</li></ul><p><strong>atTerminate</strong></p><ul><li>Discard any temporary data/results</li><li>Shut down application and any associated threads.</li></ul><h3 id="sterror" tabindex="-1">stError <a class="header-anchor" href="#sterror" aria-label="Permalink to &quot;stError&quot;">​</a></h3><p>In this condition there was an error somewhere in the simulation or communication that coupled simulation could not continue.</p><p><strong>atTerminate</strong></p><ul><li>Shut down simulation and all associated threads.</li></ul><h3 id="state-diagram" tabindex="-1">State Diagram <a class="header-anchor" href="#state-diagram" aria-label="Permalink to &quot;State Diagram&quot;">​</a></h3><p><img src="'+r+'" alt="Messaging State Digram"><br> This state diagram shows the recommended design flow for reacting to EMRALD messages outlined in the above section. Immediate actions are what should be done when entering the status state. The events are either messages from EMRALD or conditions that happen inside the simulation. The sub items under the Events are Actions to be taken if the Event occurs. Both atPing and atStatus are ignored in this diagram because they should be responded to in every state.</p><h3 id="sequence-diagram" tabindex="-1">Sequence Diagram <a class="header-anchor" href="#sequence-diagram" aria-label="Permalink to &quot;Sequence Diagram&quot;">​</a></h3><p><img src="'+l+'" alt="Messaging Sequence Digram"><br> This sequence diagram show the flow of messages between the two applicaitons.</p><h1 id="testing" tabindex="-1">Testing <a class="header-anchor" href="#testing" aria-label="Permalink to &quot;Testing&quot;">​</a></h1><p>The EMRALD simulation engine UI has a tab for testing the XMPP messaging. There also a demo client project in the source written in c#.</p><h2 id="emrald-ui" tabindex="-1">EMRALD UI <a class="header-anchor" href="#emrald-ui" aria-label="Permalink to &quot;EMRALD UI&quot;">​</a></h2><p>To couple with an external application first load a model. If it loads with no errors, then go to the simulate tab.</p><h3 id="establishing-a-connection" tabindex="-1">Establishing a connection <a class="header-anchor" href="#establishing-a-connection" aria-label="Permalink to &quot;Establishing a connection&quot;">​</a></h3><p>The external simulation or client application must then be opened and connected. Next the user clicks on the items in &quot;Links to External Simulations&quot; in the upper left. <img src="'+h+'" style="width:500px;"><br> This pops up a list of all clients currently connected to EMRALD. The user selects the correct linked application for the EMRALD item. <img src="'+c+'" style="width:300px;"><br></p><h3 id="manually-send-emrald-messages" tabindex="-1">Manually send EMRALD messages <a class="header-anchor" href="#manually-send-emrald-messages" aria-label="Permalink to &quot;Manually send EMRALD messages&quot;">​</a></h3><p>The &#39;XMPP Messaging&#39; tab allows the user to manually construct and send messages and see messages sent from a coupled application.</p><p>The left side shows the connected clients and the messages received. <img src="'+m+'" style="width:500px;"><br></p><p>The right side allows the user to manually construct a message to send to the coupled application. <img src="'+d+'" style="width:500px;"><br></p><p>If the user knows or has the JSON message to be sent they can type or paste it in the bottom right section. <img src="'+u+'" style="width:500px;"><br></p><p>By selecting and filling out the top options, a message can be automatically constructed. The options depend on the type of message selected by the user. Clicking the &quot;Generate Message&quot; button auto generates the JSON message in the box below. <img src="'+p+'" style="width:500px;"><br></p><h2 id="client-demo" tabindex="-1">Client Demo <a class="header-anchor" href="#client-demo" aria-label="Permalink to &quot;Client Demo&quot;">​</a></h2><p>The source code contains demo code for a client in c# using the MatriX package. (The XmppClient project in the EMRALD code repository <a href="https://github.com/idaholab/EMRALD" target="_blank" rel="noreferrer">EMRALD Source</a>) This project allows you to see the messages coming from the EMRALD simulation and respond to them manually. This allows you to independently test and verify the EMRALD model before connecting to the external application.</p><p><strong>Connections/Send Tab</strong><br> After EMRALD is running define the user, domain and resource. (See above section Message Requirements -&gt; Connecting) Then click connect. <img src="'+g+'" style="width:300px;"><br></p><p>After connecting this tab allows you to manually send messages to the connected EMRALD simulation or other clients connected. This can be done by pasting the message in the bottom text area and selecting the client in the bottom dropdown, and clicking &quot;Send&quot;. For assistance in constructing a message options can be selected in the center area. The items DispName, Occur time and Event Msg Type need to be assigned for every message. When selecting the Event Msg Type, the sub options will very as needed. Refer to Messaging requirements above to determine what values to set for each message. After assigning the values click the &quot;Generate Message&quot; button and correctly syntax-ed JSON will be generated in the text area below. Then click send. <img src="'+f+'" style="width:300px;"><br></p><p><strong>Received Messages</strong><br> Each message received is posted in this tabs list. <img src="'+b+'" style="width:300px;"><br></p>',96),E=[M];function T(y,S,v,D,q,x){return a(),t("div",null,E)}const R=e(w,[["render",T]]);export{P as __pageData,R as default};
